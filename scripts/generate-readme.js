import utils from "./include/utils.js";
import path from 'path';
import SettingsAccessor from "./include/settings-accessor.js";
import fs from "fs";

const __root = utils.getRootDirectory();
const __readmeTemplatePath = path.join(__root, "build/README.template.md");
const __readmeContentPath = path.join(__root, "build/README.content.md");
const __readmePath = path.join(__root, "README.md");
const __autoGeneratedComment = "<!-- This README.md was autogenerated by script. Edit build/README.content.md instead, and run `nmp run generateReadme` -->";

function readTemplate() {
	let content = fs.readFileSync(__readmeTemplatePath, "utf8");

	// Remove the leading template comment if present
	const templateHeaderPattern = /^<!--\s*README Template[\s\S]*?-->\s*/i;
	content = content.replace(templateHeaderPattern, "");

	return content.trim();
}

function readContent() {
	/* 
	The format of the content in __readmeContentPath is: 
	<!-- TOC-SECTION-MARKER -->
	...
	table of content comes here up to the content comment
	...
	
	<!-- CONTENT-SECTION-MARKER -->
	...
	content comes here
	...
	*/

	const raw = fs.readFileSync(__readmeContentPath, "utf8");

	const tocMarker = "<!-- TOC-SECTION-MARKER -->";
	const contentMarker = "<!-- CONTENT-SECTION-MARKER -->";

	const tocStart = raw.indexOf(tocMarker);
	const contentStart = raw.indexOf(contentMarker);

	if (tocStart === -1 || contentStart === -1 || contentStart < tocStart) {
		throw new Error("Invalid build/README.content.md format. Ensure it includes <!-- TOC-SECTION-MARKER --> and   <!-- CONTENT-SECTION-MARKER --> in the correct order.");
	}

	const toc = applyPlaceholders(raw.slice(tocStart + tocMarker.length, contentStart).trim(),  SettingsAccessor.projectSettings);
	const content = applyPlaceholders(raw.slice(contentStart + contentMarker.length).trim(),  SettingsAccessor.projectSettings);

	return {
		toc,
		content
	};
}

function applyPlaceholders(template, settings) {
	return template.replace(/{{([\w:.-]+)}}/g, (match, key) => {
		const value = resolveKey(settings, key);
		return value != null ? value : match;
	});
}

function resolveKey(obj, key) {
	if (!key || typeof key !== 'string') return null;
	return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;
}

function applyContentPlaceholders(template, content) {
	return template
		.replace(/{{::readme-content:toc::}}/g, content.toc)
		.replace(/{{::readme-content::}}/g, content.content);
}

function generateReadme() {
	let template = readTemplate();
	let content = readContent();

	template = applyPlaceholders(template, SettingsAccessor.projectSettings);
	template = applyContentPlaceholders(template, content);

	const finalOutput = `${__autoGeneratedComment}\n\n${template.trim()}\n`;

	fs.writeFileSync(__readmePath, finalOutput, "utf8");
	console.log("âœ… README.md generated successfully.");
}

generateReadme();